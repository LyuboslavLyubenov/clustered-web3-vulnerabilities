# Cluster -1352

**Rank:** #87  
**Count:** 196  

## Label
Cryptographic signature validation flaws due to incorrect message encoding or structural mismatches, leading to forgery, invalid signer recovery, or failed verification under standardized hashing rules.

## Cluster Information
- **Total Findings:** 196

## Examples

### Example 1

**Auto Label:** ECDSA signature validation flaws enabling replay, malleability, and forgery due to insufficient parameter checks, missing sender binding, or improper validation logic.  

**Original Text Preview:**

## Severity

**Impact:** High

**Likelihood:** Low

## Description

[CoWSwapClone::isValidSignature()](https://github.com/Storm-Labs-Inc/cove-contracts-core/blob/6b607d137f898c0f421b4ba4e748f41b09b41518/src/swap_adapters/CoWSwapClone.sol#L86) do not check app data field.

This applies to all ERC-1271 orders where the app data field can be changed by an adversary in a way that keeps the signature valid for that order (for example, because isValidSignature ignores the appData field in the order).

An adversary can manipulate vulnerable ERC-1271 orders, thereby transferring part of the expected surplus from the user order to an address that the adversary controls.

More details can be seen [here](https://docs.cow.fi/cow-protocol/reference/contracts/core#loss-of-surplus-if-erc-1271-order-allows-arbitrary-app-data).

## Recommendations

making the app data immutable at deployment time (or equal to bytes(0)), and
have isValidSignature reject an order if the app data doesn't match.

---
### Example 2

**Auto Label:** ECDSA signature validation flaws enabling replay, malleability, and forgery due to insufficient parameter checks, missing sender binding, or improper validation logic.  

**Original Text Preview:**

The signature verification mechanism in `IvSignerRecovery.sol` relies exclusively on ECDSA recovery for validating signatures:

```solidity
function _recoverSigner(
    SplitSig memory sig,
    uint256 iv,
    IStrategy strategy,
    uint256 maturityDate,
    uint256 relativeStrike
) internal view returns (address) {
    // Uses ECDSA recovery directly
    return _digest(iv, strategy, maturityDate, relativeStrike).recover(sig.v, sig.r, sig.s);
}
```

This implementation only supports signatures from Externally Owned Accounts (EOAs) and lacks compatibility with **EIP-1271** (`Standard Signature Validation Method for Contracts`). As a result, users with smart contract wallets (such as Gnosis Safe) cannot use the protocol's option buying functionality in the `OperationalTreasury.buy()` function, because their contract-based signatures cannot be verified by `ECDSA.recover`.

With the growing adoption of smart contract wallets for enhanced security features and multi-signature capabilities, this limitation unnecessarily restricts the protocol's user base.

Extend the signature verification logic to support EIP-1271. This typically involves checking if the signer's address corresponds to a contract. If it is a contract, call its `isValidSignature` function to confirm the signature's validity according to the contract's own logic.

---
### Example 3

**Auto Label:** ECDSA signature validation flaws enabling replay, malleability, and forgery due to insufficient parameter checks, missing sender binding, or improper validation logic.  

**Original Text Preview:**

**Description:** Support for smart accounts (e.g. [ERC-4337](https://eips.ethereum.org/EIPS/eip-4337)) and other smart contract wallets (e.g. Safe{Wallet}) minting tokens is not currently possible as the signature verification implemented in `_verifySignature` is only able to handle those generated by EOAs. Here, it could be beneficial to support signature verification not just for smart accounts but also other smart contracts that could include multi-sig wallets or any other use case, for example DAOs with their own smart contract infrastructure, to allow other organizations to participate as members.

EOAs upgraded to [ERC-7702](https://eips.ethereum.org/EIPS/eip-7702) accounts are unaffected, but any other smart contract signatures cannot be verified without implementing [ERC-1271](https://eips.ethereum.org/EIPS/eip-1271). However, this adds the additional consideration that for EIP-7702 accounts the code length will be non-zero, so while these accounts can have their signatures verified using EIP-1271, the private key still holds full authority to sign transactions which means that any implementation of a code length check such as in the [OpenZeppelin SignatureChecker library](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/cryptography/SignatureChecker.sol) will need to be slightly modified to continue to allow verification of signatures from these accounts generated using `eth/personal_sign`. Additional discussion can be found [here](https://blog.rhinestone.wtf/unlocking-chain-abstracted-eoas-with-eip-7702-and-irrevocable-signatures-adc820a150ef).

To support such smart contract signatures, consider falling back to the OpenZeppelin SignatureChecker library function `isValidERC1271SignatureNow` like so:

```diff
    function _verifySignature(bytes memory signature) internal view returns (bool) {
        /// @dev compute the message hash: keccak256(termsHash, msg.sender)
        bytes32 messageHash = keccak256(abi.encodePacked(s_termsHash, msg.sender));

        /// @dev apply Ethereum signed message prefix
        bytes32 ethSignedMessageHash = MessageHashUtils.toEthSignedMessageHash(messageHash);

        /// @dev attempt to recover the signer
        //slither-disable-next-line unused-return
        (address recovered, ECDSA.RecoverError error,) = ECDSA.tryRecover(ethSignedMessageHash, signature);

        /// @dev return false if errors or incorrect signer
++      if (error == ECDSA.RecoverError.NoError && recovered == msg.sender) return true;
++      else return SignatureChecker.isValidERC1271SignatureNow(msg.sender, ethSignedMessageHash, signature);
    }
```

**Evo:**
Fixed in commit [6d4f41c](https://github.com/contractlevel/sbt/commit/6d4f41ce160e19713bb4a6cafdf1b739df98e027#diff-39790f8feee6ea105eee119137d7c3d881007ed50d9a62590b54ff559f45b27aL511-R514).

**Cyfrin:** Verified.

\clearpage

---
