# Cluster -1401

**Rank:** #272  
**Count:** 31  

## Label
Insufficient access control and bounds checking enable unauthorized asset withdrawals or permanent fund locking, leading to high-impact liquidity drain or user fund trapping.

## Cluster Information
- **Total Findings:** 31

## Examples

### Example 1

**Auto Label:** **Improper error handling in critical operations enables governance-controlled denial of withdrawals, allowing attackers to block fund retrieval through contract upgrades.**  

**Original Text Preview:**

## Severity: Medium Risk

## Context
`ATokenERC6909.sol#L440-L446`

## Description
When deploying a minipool, underlying tokens are checked to see if they are aTokens from the main lending pool.

### ATokenERC6909.sol#L440-L446:
```solidity
function _determineIfAToken(address underlying, address MLP) internal view returns (bool) {
    try IAToken(underlying).getPool() returns (address pool) {
        return pool == MLP;
    } catch {
        return false;
    }
}
```

However, this logic is flawed for tokens that have a fallback function, such as WETH9. The `try/catch` clause is there to handle the revert in the case where the `getPool` function does not exist on the token; but in the case of WETH9, the fallback function is executed, which attempts a deposit. As a result, an EVM error (attempt to write to storage during staticcall) is thrown instead of a revert, consuming all of the remaining gas in the context.

Note that in Oracle, limiting gas passed is used as a workaround for this:

### Oracle.sol#L130-L137:
```solidity
// Check if `asset` is an aToken.
try ATokenNonRebasing(asset).UNDERLYING_ASSET_ADDRESS{gas: 4000}() returns (
    address underlying_
) {
    underlying = underlying_;
} catch {
    underlying = asset;
}
```

While this works, it is not a very robust solution (for example, aToken logic is upgraded and needs more than 4000 gas to get the underlying asset).

## Impact
When attempting to deploy minipools that have WETH9 as underlying, the call will always revert due to out of gas. Please note that due to EIP-150, only 63/64 of gas is passed on to the `IAToken(underlying).getPool()`, so the call can technically succeed by wasting an enormous amount of gas.

## Recommendation
Use a low-level call (as opposed to the `staticcall` generated by Solidity due to using a view function) to get the pool value. This way, in the case of the WETH9 fallback function, the function would succeed but would not yield a uint value, and would be correctly treated as a non-aToken.

## Cod3x
Fixed `_determineIfAToken` in commits `a0b5ca43` and `208aa500`. Fixed oracle in commits `899875bc` and `c37de4d0`.

## Spearbit
Fix verified.

---
### Example 2

**Auto Label:** **Improper error handling in critical operations enables governance-controlled denial of withdrawals, allowing attackers to block fund retrieval through contract upgrades.**  

**Original Text Preview:**

## Context
No context files were provided by the reviewer.

## Description
The current implementation lacks mechanisms to claim various rewards that accrue to the protocol from different sources. This affects:

## Aave Protocol Rewards:
- Staked AAVE tokens rewards.
- Chain-specific incentive campaign rewards (ARB, OP, ZKSYNC tokens).
- Protocol integration specific incentives (e.g., SNX incentives for providing sUSD).
- Other protocol-specific rewards.

## Reserve Manager Contract Rewards:
- EigenLayer rewards.

Rewards accrue to the wrapped rebasing token wrapper contract as it holds the underlying funds. There is no implementation to call `claimAllRewards` or utilize `allowClaimOnBehalf` functions on the `RewardsController` contract for Aave and `RewardsCoordinator` for EigenLayer.

## Impact
- Accrued rewards become effectively locked in the protocol.
- Loss of value for protocol participants who should benefit from these reward mechanisms.
- Reduced protocol efficiency as incentive mechanisms cannot be fully utilized.
- Potential compound effect as unclaimed rewards may also miss out on additional yield opportunities.

## Recommendation
- Implement mechanism to claim rewards from specific integrations.
- Ensure rewards are re-invested, distributed to the user, or withdrawn.
- Write test cases to verify the same.

## Level
Fixed in PR 25.

## Cantina Managed
Fixed.

---
### Example 3

**Auto Label:** Insufficient access control and bounds checking enable unauthorized asset withdrawals or permanent fund locking, leading to high-impact liquidity drain or user fund trapping.  

**Original Text Preview:**

## Context: Liquidation.sol#L80

## Description
Self liquidation with sub-accounts is allowed, which can enable "future unknown protocol attacks". The Euler v1 hack was enabled by two flaws in its system:

1. First, an issue with `donateToReserves` allowed the attacker to put themselves in a liquidatable state.
2. Second, the system did not prevent self liquidations.

By leveraging these two problems, the attacker was able to liquidate themselves for profit, draining the whole protocol.

In Euler v2, the developers decided to disallow self-liquidations to prevent similar attacks, but they failed to account for sub-accounts. As a result, sub-accounts are allowed to liquidate other sub-accounts controlled by the same owner. Although this by itself does not create any issues leading to loss of funds, it is a prerequisite of a major hack that happened in the past. Since Euler is putting a lot of effort into preventing "future unknown protocol attacks", as stated in the EVK whitepaper, it is advisable that this door is also closed to reduce the attack surface of the system.

Since this vulnerability does not explain a clear path leading to loss of funds, it is classified as a Low severity issue.

## Recommendation
Do not allow sub-accounts from the same owner to liquidate themselves.

---
